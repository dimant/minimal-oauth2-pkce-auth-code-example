using System.Security.Cryptography;

namespace AuthServer
{
    public class AuthorizationCodeHandler
    {
        public class AuthorizationCodeRecord
        {
            public string TenantId { get; set; } = string.Empty;
            public string ClientId { get; set; } = string.Empty;
            public string Username { get; set; } = string.Empty;
            public List<string> Scopes { get; set; } = new List<string>();
            public string CodeChallenge { get; set; } = string.Empty;
            public string CodeChallengeMethod { get; set; } = string.Empty;
        }

        private readonly Dictionary<string, AuthorizationCodeRecord> _codes;

        public AuthorizationCodeHandler()
        {
            _codes = new Dictionary<string, AuthorizationCodeRecord>();
        }

        /// <summary>
        /// Generates a new authorization code and stores it along with the 
        /// associated data.
        /// We also store information about the authorization request, such as the
        /// client ID, username, scopes, and PKCE code challenge. The challenge is
        /// generated by the client. The client will generate a random string, then
        /// hash it and send us the hash (the challenge) when requesting the 
        /// authorization code. Later, when the client redeems the authorization code,
        /// it will send us the original random string (the verifier), and we will 
        /// hash it and compare it to the stored challenge
        /// </summary>
        /// <param name="tenantId">The tenant ID.</param>
        /// <param name="clientId">The client ID.</param>
        /// <param name="username">The username of the authenticated user.</param>
        /// <param name="scopes">The scopes granted.</param>
        /// <param name="codeChallenge">The PKCE code challenge.</param>
        /// <param name="codeChallengeMethod">The PKCE code challenge method.</param>
        /// <returns>The generated authorization code.</returns>
        public string GenerateCode(string tenantId, string clientId, string username, List<string> scopes, string codeChallenge, string codeChallengeMethod)
        {
            // Generate a cryptographically secure random code
            byte[] randomBytes = new byte[64];
            using (var rng = RandomNumberGenerator.Create())
            {
                rng.GetBytes(randomBytes);
            }
            string authCode = Convert.ToBase64String(randomBytes)
                .Replace("+", "-")
                .Replace("/", "_")
                .TrimEnd('=');
            
            _codes[authCode] = new AuthorizationCodeRecord
            {
                TenantId = tenantId,
                ClientId = clientId,
                Username = username,
                Scopes = scopes,
                CodeChallenge = codeChallenge,
                CodeChallengeMethod = codeChallengeMethod
            };

            return authCode;
        }

        /// <summary>
        /// Validates the authorization code and PKCE code verifier. 
        /// We receive the authorization code we handed to the client when it
        /// called the /authorize endpoint. We also receive the code verifier 
        /// that the client generated initially. The client sends us a challenge
        /// to the /authorize endpoint.
        /// To generate the challenge, the client created a random string (the
        /// code verifier), hashed it using SHA256, and encoded it in a URL-safe
        /// base64 format (the code challenge). When we validate, we receive the
        /// verifier, which is the original random string. We hash it and compare
        /// the result to the stored challenge which replicates what the client did
        /// to generate the code challenge. If our computed challenge matches the
        /// stored challenge, the validation is successful.
        /// </summary>
        /// <param name="code">The authorization code.</param>
        /// <param name="codeVerifier">The PKCE code verifier.</param>
        /// <returns>The authorization code record if valid; otherwise, null.</returns>
        /// <remarks>
        /// This method supports only the S256 code challenge method.
        /// </remarks>
        public AuthorizationCodeRecord? ValidateCode(string code, string codeVerifier)
        {
            AuthorizationCodeRecord? record;
            if (!_codes.TryGetValue(code, out record))
            {
                return null;
            }

            if (record.CodeChallengeMethod == "S256")
            {
                // Compute SHA256 hash of the code verifier
                using (var sha256 = SHA256.Create())
                {
                    byte[] verifierBytes = System.Text.Encoding.UTF8.GetBytes(codeVerifier);
                    byte[] hashBytes = sha256.ComputeHash(verifierBytes);
                    string computedChallenge = Convert.ToBase64String(hashBytes)
                        .Replace("+", "-")
                        .Replace("/", "_")
                        .TrimEnd('=');

                    if (computedChallenge == record.CodeChallenge)
                    {
                        return record;
                    }
                    else
                    {
                        return null;
                    }
                }
            }
            else if (record.CodeChallengeMethod == "plain")
            {
                // Plain method is not secure and generally not recommended
                throw new NotImplementedException("Plain code challenge method is not supported in this implementation.");
            }
            else
            {
                throw new NotImplementedException($"Code challenge method '{record.CodeChallengeMethod}' is not supported.");
            }
        }
    }
}