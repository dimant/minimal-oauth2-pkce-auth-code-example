<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OAuth2 Demo</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 600px; margin: 0 auto; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        .result { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
        .success { background-color: #e8f5e9; }
        .error { background-color: #ffebee; }
    </style>
</head>
<body>
    <div class="container">
        <h1>OAuth2 Demo</h1>
        <button onclick="startOAuth2Flow()">Login with OAuth2</button>
        <button onclick="callProtectedResource()" id="protectedBtn" style="display:none;">Call Protected Resource</button>
        <div id="result"></div>
    </div>

    <script>
        const AUTH_SERVER = 'http://localhost:5000';
        const RESOURCE_SERVER = 'http://localhost:5001';
        const CLIENT_ID = 'app1';
        const REDIRECT_URI = 'http://localhost:5002/#/callback';
        const SCOPES = 'read write';
        const TENANT_ID = 'tenant1';
        let accessToken = null;

        // Generate PKCE code challenge
        async function generatePKCE() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            const codeVerifier = btoa(String.fromCharCode.apply(null, array))
                .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const hash = await crypto.subtle.digest('SHA-256', data);
            const codeChallenge = btoa(String.fromCharCode.apply(null, new Uint8Array(hash)))
                .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            
            return { codeVerifier, codeChallenge };
        }

        // Start OAuth2 Authorization Code Flow with PKCE
        async function startOAuth2Flow() {
            const { codeVerifier, codeChallenge } = await generatePKCE();
            sessionStorage.setItem('codeVerifier', codeVerifier);
            
            const params = new URLSearchParams({
                client_id: CLIENT_ID,
                redirect_uri: REDIRECT_URI,
                scope: SCOPES,
                code_challenge: codeChallenge,
                code_challenge_method: 'S256'
            });
            
            window.location.href = `${AUTH_SERVER}/${TENANT_ID}/oauth2/v2.0/authorize?${params}`;
        }

        // Handle callback from authorization server
        async function handleCallback() {
            const hash = window.location.hash.substring(1); // Remove the #
            const queryIndex = hash.indexOf('?');
            const queryString = queryIndex !== -1 ? hash.substring(queryIndex + 1) : hash;
            const params = new URLSearchParams(queryString);
            const code = params.get('code');
            
            if (!code) {
                displayResult('No authorization code received', 'error');
                return;
            }

            const codeVerifier = sessionStorage.getItem('codeVerifier');
            if (!codeVerifier) {
                displayResult('Code verifier not found in session', 'error');
                return;
            }

            try {
                // Exchange authorization code for access token
                const formData = new FormData();
                formData.append('grant_type', 'authorization_code');
                formData.append('code', code);
                formData.append('redirect_uri', REDIRECT_URI);
                formData.append('client_id', CLIENT_ID);
                formData.append('code_verifier', codeVerifier);

                const response = await fetch(`${AUTH_SERVER}/${TENANT_ID}/oauth2/v2.0/token`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (response.ok) {
                    accessToken = data.access_token;
                    sessionStorage.setItem('accessToken', accessToken);
                    displayResult(`Obtained an access token.`, 'success');
                    document.getElementById('protectedBtn').style.display = 'inline-block';
                    // Clear the code verifier after use
                    sessionStorage.removeItem('codeVerifier');
                } else {
                    displayResult(`Error: ${data.error}`, 'error');
                }
            } catch (error) {
                displayResult(`Error: ${error.message}`, 'error');
            }
        }

        function displayResult(message, type) {
            const resultDiv = document.getElementById('result');
            resultDiv.className = `result ${type}`;
            resultDiv.textContent = message;
        }

        // Call the protected resource endpoint
        async function callProtectedResource() {
            if (!accessToken) {
                accessToken = sessionStorage.getItem('accessToken');
                if (!accessToken) {
                    displayResult('No access token available. Please login first.', 'error');
                    return;
                }
            }

            try {
                const response = await fetch(`${RESOURCE_SERVER}/protected`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    displayResult(`Success: ${JSON.stringify(data, null, 2)}`, 'success');
                } else {
                    displayResult(`Error: ${response.status} ${data.error || 'Unauthorized'}`, 'error');
                }
            } catch (error) {
                displayResult(`Error: ${error.message}`, 'error');
            }
        }

        // Check if this is a callback
        if (window.location.hash.includes('code=')) {
            handleCallback();
        }
    </script>
</body>
</html>